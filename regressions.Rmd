---
title: "regressions"
author: "Katherine Siegel"
date: "February 10, 2020"
output: html_document
---

## Description
Get set of random forested points (2008) and run logistic regression on factors contributing to likelihood of transitioning to another land cover in 2018.

## Set up
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

### Open packages
library(tidyverse)
library(sf)
library(raster)

### Function to sample non-NA cells
### r: raster, n: number of points
### source: https://gis.stackexchange.com/questions/207119/sampling-random-points-from-large-raster-file-with-replacement-using-r
fastRandomPoints <- function(r, n) {
  if(raster::nlayers(r) > 1) r <- r[[1]]
  v <- raster::getValues(r)
  v.notNA <- which(!is.na(v))
  x <- sample(v.notNA, n)
  pts <- raster::xyFromCell(r, x)
  return(pts)
}

#### Function to check correlation
cor.prob <- function (X, dfr = nrow(X) - 2) {
  R <- cor(X, use="pairwise.complete.obs")
  above <- row(R) < col(R)
  r2 <- R[above]^2
  Fstat <- r2 * dfr/(1 - r2)
  R[above] <- 1 - pf(Fstat, 1, dfr)
  R[row(R) == col(R)] <- NA
  R
}
flattenSquareMatrix <- function(m) {
  if( (class(m) != "matrix") | (nrow(m) != ncol(m))) stop("Must be a square matrix.") 
  if(!identical(rownames(m), colnames(m))) stop("Row and column names must be equal.")
  ut <- upper.tri(m)
  data.frame(i = rownames(m)[row(m)[ut]],
             j = rownames(m)[col(m)[ut]],
             cor=t(m)[ut],
             p=m[ut])
}
```

## Get sample points
Sample points that are ag in 2008.
forest, agriculture, urban, water, desert, wetlands, and bare soil
Based on looking at rasters, I assume these are the value/land cover class combinations:  
* 0: no data  
* 1: ag
* 2: forest
* 3: bare soil  
* 4: urban  
* 5: wetland  
* 6: desert (BOL only)  
* 7: water  

### Brazil
```{r}
### Open Brazil 2008 raster
bra_2008 <- raster("C:/Users/Katherine Siegel/Documents/SESYNC/dinamica/remote_sensing/classi_BRA_dry_2008.tif")

# hist(bra_2008,
#      main = "Distribution of land cover classes",
#      xlab = "Land cover class", ylab = "Frequency",
#      col = "springgreen")

### Reclassification matrix (want forests + NA only)
reclass_df <- c(-1, 1.1, NA, ## change NoData, ag to NA
                1.9, 2.1, 1, ## forest = 1
                2.9, 10, NA) ## all other classes = NA
reclass_m <- matrix(reclass_df,
                ncol = 3,
                byrow = TRUE)

### Reclassify raster
bra_2008_recl <- reclassify(bra_2008, reclass_m)
hist(bra_2008_recl,
     main = "Distribution of land cover classes",
     xlab = "Land cover class", ylab = "Frequency",
     col = "springgreen")

### Get sample of points that are forest (1) in 2008
### Tried with sample of 1000 pts but didn't get enough points with a transition (59 turned to ag, 8 to bare soil, 1 to wetland)
forest_pts <- fastRandomPoints(r = bra_2008_recl,
                               n = 10000)

### Make it a df
forest_pts <- as_data_frame(forest_pts) %>%
  rownames_to_column(., "sample_pt")

### Convert to sf
forest_pts_sf <- st_as_sf(x = forest_pts,
                          coords = c("x", "y"),
                          crs = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

### Save sf df
st_write(forest_pts_sf, "bra_pts_for_regression.shp")
```

#### See LUC in 2018 for pts
```{r}
### Convert to sp
forest_pts_sp <- as(forest_pts_sf, "Spatial")

### Open 2018 raster
bra_2018 <- raster("C:/Users/Katherine Siegel/Documents/SESYNC/dinamica/remote_sensing/classi_BRA_dry_2018.tif")

### Extract raster values to sample pts
luc_2018 <- raster::extract(bra_2018, forest_pts_sp, df = TRUE)

### Histogram and summary
hist(luc_2018$classi_BRA_dry_2018)
luc_2018_summ <- luc_2018 %>% 
  group_by(classi_BRA_dry_2018) %>% 
  summarise(pts_per_class = n())
```

### Bolivia
```{r}
### Open Bolivia 2008 raster
bol_2008 <- raster("C:/Users/Katherine Siegel/Documents/SESYNC/dinamica/remote_sensing/classi_BOL_dry_2008.tif")

hist(bol_2008,
     main = "Distribution of land cover classes",
     xlab = "Land cover class", ylab = "Frequency",
     col = "springgreen")

### Reclassification matrix (want forests + NA only)
reclass_df <- c(-1, 1.1, NA, ## change NoData, ag to NA
                1.9, 2.1, 1, ## forest = 1
                2.9, 10, NA) ## all other classes = NA
reclass_m <- matrix(reclass_df,
                ncol = 3,
                byrow = TRUE)

### Reclassify raster
bol_2008_recl <- reclassify(bol_2008, reclass_m)
hist(bol_2008_recl,
     main = "Distribution of land cover classes",
     xlab = "Land cover class", ylab = "Frequency",
     col = "springgreen")

### Get sample of points that are forest (1) in 2008
forest_pts_bol <- fastRandomPoints(r = bol_2008_recl,
                                   n = 10000)

### Make it a df
forest_pts_bol <- as_data_frame(forest_pts_bol) %>%
  rownames_to_column(., "sample_pt")

### Convert to sf
forest_pts_bol_sf <- st_as_sf(x = forest_pts_bol,
                          coords = c("x", "y"),
                          crs = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

### Save sf df
st_write(forest_pts_bol_sf, "bol_pts_for_regression.shp")
```

#### See LUC in 2018 for pts
```{r}
### Convert to sp
forest_pts_bol_sp <- as(forest_pts_bol_sf, "Spatial")

### Open 2018 raster
bol_2018 <- raster("C:/Users/Katherine Siegel/Documents/SESYNC/dinamica/remote_sensing/classi_BOL_dry_2018.tif")

### Extract raster values to sample pts
luc_2018_bol <- raster::extract(bol_2018, 
                                forest_pts_bol_sp, 
                                df = TRUE)

### Histogram and summary
hist(luc_2018_bol$classi_BOL_dry_2018)
luc_2018_bol_summ <- luc_2018_bol %>% 
  group_by(classi_BOL_dry_2018) %>% 
  summarise(pts_per_class = n())
```

### Peru
```{r}
### Open Peru 2008 raster
per_2008 <- raster("C:/Users/Katherine Siegel/Documents/SESYNC/dinamica/remote_sensing/classi_PER_dry_2008.tif")

hist(per_2008,
     main = "Distribution of land cover classes",
     xlab = "Land cover class", ylab = "Frequency",
     col = "springgreen")

### Reclassification matrix (want forests + NA only)
reclass_df <- c(-1, 1.1, NA, ## change NoData, ag to NA
                1.9, 2.1, 1, ## forest = 1
                2.9, 10, NA) ## all other classes = NA
reclass_m <- matrix(reclass_df,
                ncol = 3,
                byrow = TRUE)

### Reclassify raster
per_2008_recl <- reclassify(per_2008, reclass_m)
hist(per_2008_recl,
     main = "Distribution of land cover classes",
     xlab = "Land cover class", ylab = "Frequency",
     col = "springgreen")

### Get sample of points that are forest (1) in 2008
### 10,000 pts is not enough for Peru-- only had 27 points that transitioned
## 30,000 pts --> 92 transitioned
forest_pts_per <- fastRandomPoints(r = per_2008_recl,
                                   n = 100000)

### Make it a df
forest_pts_per <- as_data_frame(forest_pts_per) %>%
  rownames_to_column(., "sample_pt")

### Convert to sf
forest_pts_per_sf <- st_as_sf(x = forest_pts_per,
                          coords = c("x", "y"),
                          crs = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

### Save sf df
st_write(forest_pts_per_sf, "per_pts_for_regression.shp")
```

#### See LUC in 2018 for pts
```{r}
### Convert to sp
forest_pts_per_sp <- as(forest_pts_per_sf, "Spatial")

### Open 2018 raster
per_2018 <- raster("C:/Users/Katherine Siegel/Documents/SESYNC/dinamica/remote_sensing/classi_PER_dry_2018.tif")

### Extract raster values to sample pts
luc_2018_per <- raster::extract(per_2018, 
                                forest_pts_per_sp, 
                                df = TRUE)

### Summary
luc_2018_per_summ <- luc_2018_per %>% 
  group_by(classi_PER_dry_2018) %>% 
  summarise(pts_per_class = n())

# ### Double check that all pts are forest in 2008
# lc_2008 <- raster::extract(per_2008,
#                            forest_pts_per_sp, 
#                            df = TRUE)
# lc_2008_per_summ <- lc_2008 %>% 
#   group_by(classi_PER_dry_2008) %>% 
#   summarise(pts_per_class = n())
```

## Simple Models
### Brazil
#### Assemble datasets
Extract values from rasterbricks to sample points
```{r}
### Open Brazil sample pts, reproject to 102033
bra_pts <- st_read("bra_pts_for_regression.shp") %>%
  st_transform(., crs = 102033)

### Open Brazil rasterbrick
bra_layers <- brick("D:/dinamica/brazil_simple/data/brazil_static_vars.tif")

### Convert pts to sp
bra_pts_sp <- as(bra_pts, "Spatial")

### Extract values to pts
bra_dat <- extract(bra_layers, 
                   bra_pts_sp,
                   df = TRUE)

### Rename columns
colnames(bra_dat) <- c("id", "aspect", "mines", 
                       "roads", "rivers", 
                       "cities", "elev", 
                       "popdens", "poverty", 
                       "ppt", "prot_status", 
                       "slope", "soil", 
                       'crop_suit')

### Open 2018 land cover map
bra_2018_lc <- raster("D:/dinamica/brazil_simple/data/classi_bra_dry_2018_102033.tif")

### Extract 2018 land cover class to points
pts_2018 <- extract(bra_2018_lc, 
                    bra_pts_sp,
                    df = TRUE)
colnames(pts_2018) <- c("id", "lc_2018")

### Combine dfs
bra_dat <- merge(bra_dat, pts_2018, by = "id")

### Make column for transition/none
bra_dat <- bra_dat %>%
  mutate(transition = ifelse(lc_2018 == "2",
                             "no_change",
                             "change"),
         trans_rc = ifelse(transition == "no_change",
                           "0", "1"))

### Make columns factor
fact_cols <- c("id", "prot_status", "lc_2018", "trans_rc")
bra_dat <- bra_dat %>%
  mutate_each_(funs(factor(.)), fact_cols)
```

#### Check correlations
```{r}
### Make corr table
cor_table_bra <- flattenSquareMatrix(cor.prob(bra_dat[, c(2:10, 12:14)]))

### Look at vars with abs(cor.prob) > 0.66 and pvalue < 0.05
cor_table_bra <- subset(cor_table_bra, 
                        abs(cor) > 0.66 & p <= 0.05)

### Population density and poverty rate are highly correlated (correlation coefficient = 0.92)

### Make updated dataset
bra_dat_red <- bra_dat %>%
  dplyr::select(-poverty)

### Drop incomplete rows
bra_dat_comp <- bra_dat_red[complete.cases(bra_dat_red), ]

### Drop rows where prot_status = 0 (??)
bra_dat_comp <- bra_dat_comp %>%
  filter(., !prot_status == "0")
```

#### Regression
```{r}
### Run regression
fit_bra <- glm(trans_rc ~ aspect + slope + elev +
                 roads + rivers + cities + mines +
                 ppt + soil + crop_suit +
                 popdens + prot_status,
               data = bra_dat_comp,
               family = binomial(link = "logit"))

### Write out coefficients
fit_bra_summ <- summary(fit_bra)
fit_bra_coeff <- as.data.frame(fit_bra_summ$coefficients)
write.csv(fit_bra_coeff, 
          file = "C:/Users/Katherine Siegel/Documents/SESYNC/dinamica/visuals_feb/fit_bra_simple_summary.csv")
```

### Bolivia
#### Assemble datasets
Extract values from rasterbricks to sample points
```{r}
### Open Bolivia sample pts, reproject to 102033
bol_pts <- st_read("bol_pts_for_regression.shp") %>%
  st_transform(., crs = 102033)

### Open Bolivia rasterbrick
bol_layers <- brick("D:/dinamica/bolivia_simple/data/bolivia_static_vars.tif")

### Convert pts to sp
bol_pts_sp <- as(bol_pts, "Spatial")

### Extract values to pts
bol_dat <- extract(bol_layers, 
                   bol_pts_sp,
                   df = TRUE)

### Rename columns
colnames(bol_dat) <- c("id", "aspect", "mines", 
                       "roads", "rivers", 
                       "cities", "elev", 
                       "popdens", "poverty", 
                       "ppt", "prot_status", 
                       "slope", "soil", 
                       'crop_suit')

### Open 2018 land cover map
bol_2018_lc <- raster("D:/dinamica/bolivia_simple/data/classi_bol_dry_2018_102033.tif")

### Extract 2018 land cover class to points
pts_2018 <- extract(bol_2018_lc, 
                    bol_pts_sp,
                    df = TRUE)
colnames(pts_2018) <- c("id", "lc_2018")

### Combine dfs
bol_dat <- merge(bol_dat, pts_2018, by = "id")

### Make column for transition/none
bol_dat <- bol_dat %>%
  mutate(transition = ifelse(lc_2018 == "2",
                             "no_change",
                             "change"),
         trans_rc = ifelse(transition == "no_change",
                           "0", "1"))

### Make columns factor
fact_cols <- c("id", "prot_status", "lc_2018", "trans_rc")
bol_dat <- bol_dat %>%
  mutate_each_(funs(factor(.)), fact_cols)
```

#### Check correlations
```{r}
### Make corr table
cor_table_bol <- flattenSquareMatrix(cor.prob(bol_dat[, c(2:10, 12:14)]))

### Look at vars with abs(cor.prob) > 0.66 and pvalue < 0.05
cor_table_bol <- subset(cor_table_bol, 
                        abs(cor) > 0.66 & p <= 0.05)

### Distance to roads and distance to cities highly correlated (coeff = 0.7297491)
### Poverty and soil moisture are highly correlated (coeff = 0.7979029)

### Drop poverty (because also dropped that for DINAMICA), drop distance to cities

### Make updated dataset
bol_dat_red <- bol_dat %>%
  dplyr::select(-poverty, -cities)

### Drop incomplete rows
bol_dat_comp <- bol_dat_red[complete.cases(bol_dat_red), ]

### Drop rows where prot_status = 0 (??)
bol_dat_comp <- bol_dat_comp %>%
  filter(., !prot_status == "0")
```

#### Regression
```{r}
### Run regression
fit_bol <- glm(trans_rc ~ aspect + slope + elev +
                 roads + rivers + mines +
                 ppt + soil + crop_suit +
                 popdens + prot_status,
               data = bol_dat_comp,
               family = binomial(link = "logit"))

### Write out coefficients
fit_bol_summ <- summary(fit_bol)
fit_bol_coeff <- as.data.frame(fit_bol_summ$coefficients)
write.csv(fit_bol_coeff, 
          file = "C:/Users/Katherine Siegel/Documents/SESYNC/dinamica/visuals_feb/fit_bol_simple_summary.csv")
```
